
package rohin.gameengine;

import java.util.*;

// Core game engine class.

public abstract class ECSEngine extends ECSObject
{
    // @formatter:off
    
    // Constants
    
    public static final Boolean M_GAME_LOOP_DEFAULT_TARGET_ENABLED   = true;
    public static final double  M_GAME_LOOP_DEFAULT_FPS_TARGET       = 90;
    public static final int     M_GAME_LOOP_DEFAULT_LOOP_DELAY_FIXED = 1000;
    public static final int     M_GAME_LOOP_DEFAULT_LOOP_DELAY_MIN   = 5;
    
    // Fields.
    
    // Game engine parameters.

    private List <ECSSystem> systems;                   // List of game entities.
    private List <ECSEntity> entities;                  // List of game systems.    
    private CommandManager   commandManager;            // Command invocation manager.
    private ResourceManager  resourceManager;           // Resource cache manager.
    private Boolean          loggingEnabled;            // logging switch.
    private ConsoleLogger    logger;                    // Console logger.
    private String           resourcePath;              // Disk location for all game assets. e.g. Images, sounds, vector models, etc.
    
    // Game loop management.
    
    private Boolean          loopRunning;               // Loop state. Set to true to run the game loop. Set to false to exit the game loop.
    private int              loopDelayFixed;            // Game loop, frame rate regulator. Fixed delay, measured in ms.
    private int              loopDelayVariable;         // Game loop, frame rate regulator. Dynamic delay, that adjusts to maintain target FPS.    
    private int              loopDelayMin;              // Minimum loop iteration delay.
    private double           fpsTarget;                 // Target Frames Per Second.
    private Boolean          fpsTargetEnabled;          // Choose whether to use a fixed loop delay, or a target FPS.
    
    // Game loop monitoring
    
    private double           fps;                       // Measured frames Per Second. (Animation frequency).
    private long             loopIterationTime;         // Loop iteration time. Used for display and debugging.
    
    // Accessors and mutators.

    public List <ECSSystem> getSystems         () { return this.systems;          }
    public List <ECSEntity> getEntities        () { return this.entities;         }
    public Boolean          isloggingEnabled   () { return this.loggingEnabled;   }
    public Boolean          isLoopRunning      () { return this.loopRunning;      }
    public Boolean          isFPSTargetEnabled () { return this.fpsTargetEnabled; }    
    public int              getLoopDelayFixed  () { return this.loopDelayFixed;   }
    public int              getLoopDelayMin    () { return this.loopDelayMin;     }
    public double           getFPSTarget       () { return this.fpsTarget;        }        
    public CommandManager   getCommandInvoker  () { return this.commandManager;   }
    public String           getResourcePath    () { return this.resourcePath;     }
    public ResourceManager  getResourceManager () { return this.resourceManager;  }    
    
    public void setCommandInvoker   ( CommandManager  commandInvoker   ) { this.commandManager   = commandInvoker;   }
    public void setloggingEnabled   ( Boolean         loggingEnabled   ) { this.loggingEnabled   = loggingEnabled;   }
    public void setLoopRunning      ( Boolean         loopRunning      ) { this.loopRunning      = loopRunning;      }
    public void setLoopDelayFixed   ( int             loopDelayFixed   ) { this.loopDelayFixed   = loopDelayFixed;   }
    public void setLoopDelayMin     ( int             loopDelayMin     ) { this.loopDelayMin     = loopDelayMin;     }
    public void setFPSTargetEnabled ( Boolean         fpsTargetEnabled ) { this.fpsTargetEnabled = fpsTargetEnabled; }
    public void setFPSTarget        ( double          fpsTarget        ) { this.fpsTarget        = fpsTarget;        }
    public void setResourcePath     ( String          resourcePath     ) { this.resourcePath     = resourcePath;     }
    public void setResourceManager  ( ResourceManager resourceManager  ) { this.resourceManager  = resourceManager;  }
    
    // Abstract methods.
    
    public abstract void swapBuffer ();     // Swap the double buffers in order to show the most recently drawn animation frame.
    
    // Constructors.

    public ECSEngine ()                  { initialize ( null  ); }
    public ECSEngine ( ECSEngine owner ) { initialize ( owner ); }    
    
    // Initialize
    
    private void initialize ( ECSEngine owner )
    {
        // Initialize game engine parameters.
        
        this.owner           = owner;
        this.systems         = new ArrayList <ECSSystem> ();
        this.entities        = new ArrayList <ECSEntity> ();
        this.commandManager  = new CommandManager ();
        this.resourceManager = new ResourceManager ();
        this.loggingEnabled  = true;
        this.logger          = new ConsoleLogger ( this, this.loggingEnabled );
        
        // Initialize game loop parameters.
        
        this.loopRunning       = true;
        this.fpsTargetEnabled  = M_GAME_LOOP_DEFAULT_TARGET_ENABLED;
        this.fpsTarget         = M_GAME_LOOP_DEFAULT_FPS_TARGET;
        this.loopDelayFixed    = M_GAME_LOOP_DEFAULT_LOOP_DELAY_FIXED;       
        this.loopDelayMin      = M_GAME_LOOP_DEFAULT_LOOP_DELAY_MIN;
        this.loopDelayVariable = 0;        
        
        // Initialize loop monitoring points.
                
        this.loopIterationTime = 0;
        this.fps               = 0;                  
    }
    
    // @formatter:on

    // Methods.

    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    // Game loop.
    // --------------------------------------------------------------------------------------------------------------------------------------------------------

    public void run ()
    {
        this.logger.log ();
        
        long start = 0;
        long stop  = 0;
        long t     = 0;

        this.loopRunning = true;

        while ( this.loopRunning )
        {
            start = System.currentTimeMillis ();        // Start the clock.
            
            this.commandManager.flush ();               // Flush and execute commands in the command queue.
            
            for ( ECSSystem system : this.systems )     // Loop through all game systems.
            {
                system.update ( t );                    // Call Update on each of them. 
            }
            
            swapBuffer ();                              // Swap the double buffer, in order to show the last frame of the animation. 
            
            regulateFrameRate ();                       // Give the CPU some time to do other things other than spin the loop.

            stop = System.currentTimeMillis ();         // Stop the clock.
            t    = stop - start;                        // Calculate the lap time for this iteration.
        }
    }
    

    
    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    // Add system.
    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    
    public void addSystem ( ECSSystem system )
    {
        this.systems.add ( system );
    }
    
    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    // Add entity.
    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    
    public void addEntity ( ECSEntity entity )
    {
        this.entities.add ( entity );
    }
        
    public void addEntity ( int index, ECSEntity entity )
    {
        // Get the length of the entity list.
        
        int listLength = this.entities.size ();
        
        // Clip index if less than zero. We will clip if less than zero, but it is the responsibility of the caller to ensure natural integer constraints.
        
        index = ( index < 0 ) ? 0 : index;
        
        // If the index is less than or equal to the list length, then add the entity at the location referenced by the supplied index.
        // If the index is greater than the list length, then increase the length of the list to accommodate the new index.
        
        if ( index <= listLength )
        {
            if ( ( listLength > 0 ) && ( listLength > index ) )
            {
                this.entities.remove ( index );
                this.entities.add    ( index, entity );
            }
            else
            {
                this.entities.add    ( index, entity );
            }
        }
        else
        {
            for ( int i = listLength; i <= index; i++ )
            {
                if ( i == index )
                {
                    this.entities.add ( i, entity );            // Add the entity at the new maximum bound of the array.
                }
                else
                {
                    this.entities.add ( i, new ECSEntity() );   // Add a null on the way up to the new maximum array bound.
                }
            }
        }
    }
    
    // --------------------------------------------------------------------------------------------------------------------------------------------------------    
    // Variable frame rate regulation delay.
    //
    // Used to implement a variable period frame rate regulation delay, that
    // attempts to normalize the frame rate to a specified target frame rate.
    // 
    // The target frame rate is specified internally through, fpsTarget.    
    // --------------------------------------------------------------------------------------------------------------------------------------------------------

    public void regulateFrameRate ()
    {
        if ( this.fpsTargetEnabled )
        {
            // Calculate dynamic period loop delay.
            //
            // - If we are spinning faster than the target FPS, then delay the loop for the remaining time, until target FPS is reached..
            // - If we are spinning slower than the target FPS, then just force the minimum delay.
            //
            //   Note:
            //   We don't allow a minimum delay of zero, for risk of the game loop hogging the the CPU and potentially hanging the main application thread.                                   

            if ( this.fpsTarget > 0.0 )
            {
                this.loopDelayVariable = ( int ) ( 1000.0 / this.fpsTarget );
            }
            else
            {
                this.loopDelayVariable = this.loopDelayMin;
            }

            delay ( this.loopDelayVariable );             
        }
        else
        {
            // Fixed period loop delay.

            delay ( this.loopDelayFixed );
        }
    }
    
    // --------------------------------------------------------------------------------------------------------------------------------------------------------    
    // Frame rate delay.
    // 
    // Used to implement a fixed period frame rate delay.
    // 
    // Arguments:
    // - period
    //   The period to dealy in milliseconds.
    // --------------------------------------------------------------------------------------------------------------------------------------------------------
    
    public void delay ( long period )
    {           
        try
        {
            Thread.sleep ( period );
        }
        catch ( InterruptedException e )
        {
            e.printStackTrace ();
        }
    }
}











